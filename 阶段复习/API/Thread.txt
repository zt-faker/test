#多线程
多线程改变了代码的执行方式，从原来的一句一句执行到多个代码端‘一起’运行
即，从原有的串行操作改为并行操作，
但是，实际上计算机中的代码不是真正意义上的同时执行，只是在感官上是这样的，
围观下cpu执行代码时这些代码端中的代码走走停停，是cpu在轮寻，这就是并发

线程由两种创建方式：
 方式一：继承Thread重写run方法
	简单直接，在使用匿名内部类创建线程时常用
	缺点，由于java是单继承，导致继承了Thread后无法继承其他类来重用方法
	实际开发不方便
	缺点，重写run方法会导致线程要执行的任务定义在了线程中，任务与线程
	存在必然耦合关系，不利于线程重用
 方式二：实现Runnable接口单独定义线程任务

setPriority();
  线程的优先级，10个等级，1-10表示，其中1最低，5默认，10 最高
理论上线程优先级越高，获取时间片的次数越多

setDaemon(true)；
  守护线程又叫精灵线程或后台线程，守护线程在使用和创建上与普通线程
一样，但是结束时机优点不同在进程的结束上，
  当一个进程中所有普通线程都结束时，进程就会结束，此时所有正在运行
的守护线程都会被强制终止
  开启守护线程必须写在调用start方法之前才能分配为守护线程

join()方法
  join时可以协调多个线程 同步运行的方法，调用该方法的线程进入阻塞状态
直到该方法所属的线程结束后才可以解除阻塞向下执行

static void sleep(long ms)
  睡眠阻塞，线程提供的一个静态方法，该方法会让调用这个方法的线程进入阻塞
状态指定的毫秒，当超过这个毫秒后线程自动回到Runnable状态等待再次获取时
间片并发运行

interrupt()
  当一个线程调用sleep方法处于阻塞状态中该线程的interrupt方法被调用时
sleep方法就会抛出中断异常，此时等于中断了睡眠阻塞

static Thread currentThread()
  Thread的静态方法currentThread可以获取运行这个给方法的线程

线程提供了一组获取自身信息的方法：
	//获取主线程
	Thread main = Thread.currentThread();
	String name = main.getName();
	System.out.println("线程名"+name);
		
	long id = main.getId();
	System.out.println("唯一标识"+id);
	int priority =main.getPriority();
	System.out.println("优先级"+priority);
		
	boolean isAlive = main.isAlive();//显示是否活着
	boolean isDaenom = main.isDaemon();//是否为守护线程
	boolean isInter = main.isInterrupted();//是否被中断

线程池
  线程池主要解决两个问题：
	1.控制线程数量；线程过多会导致内存消耗大，
		cpu过度切换导致并发性能差
	2.重用线程；线程不应当随着任务的声明周期一致，
		避免频繁的创建和销毁线程可以降低启动
		带来的不必要开销
//创建一个固定大小的线程池(这里线程为3条)
ExecutorService  es=Executors.newFixedThreadPool(3)
	.execute();//把任务交给线程池处理
	.shutdownNow();//立刻关闭线程
	.shoudown();//运行完线程关闭

多线并发安全问题
  当多个线程并发访问统一临界资源时，由于线程切换时间不确定，
导致操作顺序出现混乱，严重时会导致系统瘫痪等后果
synchronized:
	1.当一个方法使用synchronized修饰后，该方法称为同步方法，
	这样的方法不允许多个线程同时在方法内部执行，
	将当一个线程异步操作临界资源改为同步操作就可以解决多
	线程的并发的的安全问题(抢改为排队)
  .yield();//主动放弃cpu给与的时间，模拟没时间切换

	2.同步块：synchronized(同步监视器对象){}
	同步块可更准确的锁定需要同步运行的代码段，而不是将一个
	方法所有代码锁定，有效的缩写同步范围是可以保证并发安全
	的前提下提高并发率

	使用同步块时需要指定同步监视器对象，该对象可以是java任何
	类型的实例，只要保证多个需要同步运行该同步块的线程看到的
	是【同一个】对象即可

	3.静态方法若使用synchronized，那么该方法一定具有同步效果
	静态方法上使用synchronized修饰后，那么锁对象就是当前类的
	类对象，
	每个类只有一个类对象，因此锁该对象一定又同步效果了，获取
	类对象可以通过 类名.class得到，类对象是Class类型的一个实例
	synchronized(类名.class){}
	
	4.互斥锁：当使用synchronized锁定多个代码段，并且这些
	synchronized指定的同步监视器对象是自己，这些代码段之间就是
	互斥的，多个线程不能同时执行他们，会按照先后顺序执行










	