#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
	Java虚拟机就是一个可以执行Java字节码的虚拟机进程。
	Java源文件通过javac编译器编译生成能被Java虚拟机执行的字节码文件。

	Java被设计成允许应用程序可以运行在任意平台，
	而不需要程序员为每一个平台单独重写或者重新编译。
	所谓跨平台就是在不同的平台上安装了不同的JVM，
	在不同的平台上.class文件都是一样的，
	.class文件再由对应平台的JVM解释成对应平台的机器码执行。

#解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。 
堆区:
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。
				(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，
	堆中不存放基本类型和对象引用，只存放对象本身.
3.一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

栈区:
1.每个线程包含一个栈，栈中只保存基础数据类型的对象
	和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4.由编译器自动分配释放 ，存放函数的参数值，局部变量的值等．

静态区/方法区:
1.方法区又叫静态区，跟堆一样，被所有的线程共享
	方法区包含所有的class和static变量。
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
3.―，全局变量和静态变量的存储是放在一块的，
	初始化的全局变量和静态变量在一块区域， 
	未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
――――――――――――――――

构造器
1.什么是构造器？语法？构造器允许些哪访问修饰符？
	构造器就是类实例化对象时运行的一种特殊方法
	public 类名( ){  方法体 }
	public  private  protected  default
2.普通方法能和构造器同名吗？
	可以，但是不建议使用
3.构造器什么时候被调用？
	新建一个对象的时候
4.构造器的作用是什么？
	为对象的属性赋初值

this和super
1.this有几种用法？
	this.<属性>；区分成员和局部变量
	this.<方法>()；不常用
	this();调用当前类的构造，必须写在构造方法的第一行
2.super有几种方法？
	super.<属性>
	super.<方法>();super调用父类的属性和方法是为了区分同名成员
	super();调用父类构造，必须写在构造方法中第一行
3.this和super的区别？
	this是对象在方法中的引用，调本类
	super调父类

方法重载
1.什么是方法重载？
	在同一个类中，方法名相同，参数列表不同的多个方法
2.重载的规则是什么？
	在同一个类中；
	方法名相同；
	参数列表不同(类型，顺序，数量);
	返回值和访问修饰符无关；
3.为什么要有方法重载？
	在方法功能相似，只是参数不同时
	可以使用相同的方法名定义方法，方便记忆和调用

方法重写
1.什么是方法重写？
	子类不满父类某个方法的功能，
	重新编写父类方法的现象就是重写
2.重写的规则？
	方法名，参数列表必须相同
	返回值：
	           void和基本数据类型必须相同
	           引用数据类型可以返回其子类，返回值类型<=父类
	访问修饰符：
		  子类重写的方法的访问修饰符不能比父类更严格	
	抛出的异常必须<=父类		
3.为什么要有方法重写？
	父类中的方法不能满足子类的要求

向上造型
1.什么是向上造型？语法？
	<父类类型>   <引用>  = new  <子类对象>;
	子类对象赋给父类引用
	父类引用指向子类对象
2.向上造型后，引用能访问那些方法和属性？
	只能访问父类成员，不能访问子类独有的成员
3.向上造型的意义是什么？
	子类对象可以放入父类类型的数组中，
	父类统一管理所有子类对象，
	减少代码冗余，提高可维护和可扩展性

访问控制修饰符
1.访问修饰符有那些？
			本类	同包	子类	其他
	public		  |	  |	  |	    |	宽松
	protected		  |	  |	  |
	default		  |	  |
	private		  |				严格
2.在修饰:类，方法，属性时有什么不同
	类只能被public或则默认的修饰
	通常情况下：属性设置为私有private
		    方法设置为共有public

final关键字
1.final能修饰谁?使用了会有什么结果？
	final修饰类：不能有子类，不能被继承
	final修饰方法：该方法不能被子类重写
	final修饰属性：该属性的值不能被修改，有两种赋值方式
			声明的同时赋值
		        	在构造方法中赋值
	final修饰局部变量：只能被赋值一次
	final修饰形参(形参就是已经被赋值的局部变量)：值不能修改

static关键字
1.static可以修饰谁？使用了有什么结果？
	static修饰属性：所有对象共享一个值，
		         保存在内存的方法区，节省内存
		         建议使用类名调用
		         类名.属性
	static修饰方法：静态方法或类方法
		         直接类名调用，无需实例化对象
		         静态方法中无法调用普通(实例)属性和方法，
		         因为静态方法中没有this
		         静态方法不能被重写
		         如果一个方法不需要访问当前类的实例成员，
		         就是可以定义为静态的
	static修饰初始化块：
		初始化块在构造方法运行前运行
		
		被static修饰的初始化块只运行一次，
		而且时在JVM加载这个类之前运行
		一个类可以有多
个静态初始化块

抽象类
1.什么是抽象方法？
	没有方法体的方法
	子类必须重写父类的抽象方法，除非子类也是抽象类
	抽象方法必须在抽象类中
2.什么是抽象类?
	不存在的类，一般用于父类
	不能实例化
	可以有抽象，普通，构造方法
	抽象方法数量不限
3.抽象类的意义？
	对代码的维护和重用


