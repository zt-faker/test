# 基础整理

## OOP面向对象的特征:

### 	封装

​	1.封装:将某些数据和数据的算法整理起来放入一个类中, 
	对象对内部提供了不同级别的保护, 如:public  默认  protected	private.	
	以防止程序中无关的部分意外改写了数据或错误的使用了对象私有部分

### 	继承

​	2.继承:让某个类型的对象获得另一个类型对象的属性的方法, 
	通过继承创建的类称为"子类"或"派生类",被继承的类称为"基类" , "父类"或"超类",
	子类是对父类功能的扩展, 实际开发中, 父类往往是从子类泛化而来,
	即理解为:父类将各个子类中相同的属性和方法提取出来统一管理, 需要的时候直接继承

### 	多态

​	3.多态:一个父类具体子类实例的相同方法,执行出不同的形式或形态以及不同的表现

## 静态变量和实例变量的区别

​	1.语法定义上的区别:静态变量前要加static关键字, 而实例变量前不加

​	2.程序运行时的区别:

​		2.1)实例变量属于某个对象的属性,必须先将对象实例化,
			才能分配空间,然后再使用实例变量

​		2.2)静态变量不属于某个实例对象,而是属于类,与类同级,所以也称为类变量

​		2.3)实例变量必须创建对象后才可以通过这个对象来使用,
			静态变量则可以直接通过类名来使用

## Overload(重载)和Override(重写)的却别

​		1.重写必须继承,重载不用

​		2.重写的方法名相同,参数列表相同,参数类型兼容;重载的方法名相同,参数列表不同

​		3.重写的方法修饰符保护程度不能超过父类,重载和修饰符无关

​		4.重写不能抛出父类没有抛出的一般异常,可以抛出运行时异常

## 多态的表现形式有哪些

​		多态的表现形式在于重写和重载以及向上造型

## abstract class和interface有什么区别

​		1.含有abstract修饰的类都是抽象类,抽象类不能实例化对象

​		2.abstract class类中定义抽象方法必须在具体子类中实现

​		3.如果子类没有实现父类中的所有抽象方法,那么子类必须也定义为抽象类

​		4.interface(接口)是一种特殊的抽象类,
		接口中的方法必须是抽象方法,默认定义为public abstract类型,
		接口中的成员变量默认为public static final(常量)

## 接口是否可以继承接口?抽象类是否可以实现接口?抽象类是否可以继承具体类?

​	1.接口可以继承接口,且可以继承多个接口

​	2.抽象类可以实现接口,且可以实现多个接口

​	3.抽象类可以继承具体类,且只能继承一个类

## GC是什么?GC有什么作用?

​	1.GC是java的垃圾回收机制,可以自动检测不再被引用的对象,并且释放其占用的内存

​	2.GC对于不被引用的对象等垃圾会自动进行管理

​	3.GC调用的方法:1)System.gc()	2)Runtime.getRuntime().gc()

​		以上两种方法会通知GC尽快进行垃圾回收,但不被人为操控

​	4.在对象使用以后要及时释放其引用,有利于垃圾回收,可以有效的防止内存泄漏

# JAVASE

## ArraylList,LinkedList的储存性能和特性

​	1.ArrayList是采用数组形式来保存对象的,
	这种方式是将对象放在连续的位置中,
	优点是:索引读取快,从最后插入和删除元素速度快,但是头部插入和删除慢!

​	2.LinkedList是使用双向循环链表方式来储存数据,
	所以头尾插入或读取插入的速度快,而中部插入和读取慢

## String与StringBuffer的区别是什么?StringBuffer和StringBuilder的区别是什么?

​	1.String与StringBuffer的区别:

​		String是不可改变的,而StringBuffer是可变的

​	  StringBuffer和StringBuilder的区别:

​		StringBuffer是线程安全的,而StringBuilder是非线程安全的

​	2.在由于字符串链会自动创建SringBuilder对象,
		为了避免复杂字符串拼接时候大量创建StringBuilder对象,
		可以利用StringBuilder优化字符串链操作

​		StringBuilder是jdk5之后新增的,
		用法与StringBuffer一样,但是他是线程不安全的,
		在单线程中使用最佳,因为单线程不需要维护线程的安全,因此是最快的.

## String类能不能被继承?为什么?

​	1.String类是被final修饰的类,被final修饰的类不能被继承

## equals和"=="的区别

​	1.==是值的比较,也是对于引用指向地址的比较,对比其地址是否相同

​	2.equals是判断引用指向的地址中,内容是否相同的比较

## java中的异常处理机制

​	1.在程序运行中java异常是一个消息传播机制,
	如果不被处理,则会继续传播并且打断当前程序运行,
	在java中,使用try-catch-fianlly进行异常捕获并处理异常消息

## 创建线程有几种不同的方式?

​	1.继承Thread类,并且创建对象

​	2.实现Runnable接口,将Runnable接口的具体对象作为参数创建Thread对象

​	3.使用Executer创建并重用线程(未学)

## 当一个线程进入一个对象的synchronized方法后,其他线程能否进入该对象的其他方法

​	1.可以进入该对象中其他非synchronized的方法,具有synchronized的方法不能进入

​	2.synchronized的作用是将某个对象或对象中的属性上锁,
	使方法不能并发执行,在一个线程进入synchronized上锁的对象后,
	其他线程无法进入访问,必须等到进入了synchronized的线程执行完成后才能排队一次进入执行

## 在java中什么是多线程?

​	1.在java中并发运行多个流程,每一个流程称为一个线程

​	2.java的ThreadAPI封装了线程的控制过程

​	3.创建线程对象后调用start方法就可以将线程提交到操作系统执行

## 线程的基本概念

​	1.一个线程就是进程中的一个运行的流程.
		一个进程中的全部线程共享这个流程的堆空间,
		线程具有供程序执行时的栈,一个进程中可以包含多个栈

​	2.线程的五个基本状态:新建状态  就绪状态	运行状态	阻塞状态	死亡状态

​		新建状态:利用New运算创建了线程对象时的状态.
		在调用了start方法后将线程提交给操作系统,准备执行,这时线程将会进入到就绪状态

​		就绪状态:是由操作系统进行调度的一个线程,
		没有被系统分配到处理器上执行时的状态.当处理器得空时,
		操作系统将就绪状态的线程放入到处理器中执行,这时线程将会进入到运行状态

​		运行状态:线程正在运行过程中的状态.在线程运行中,

​		阻塞状态:当线程遇到sleep()方法或者等待IO完成或等待其他方法同步完成时,
		这时线程进入阻塞状态

​		死亡状态:当线程脱离阻塞状态后,程序继续往下执行,
		当所有程序执行完毕后,线程就会进入死亡状态,当程序进入死亡状态时,
		就只能被GC回收,不再被调用

## 什么是节点流?什么是过滤流?常用的节点流和过滤流有哪些?

​	1.节点流:有明确的数据源,从数据源读取基础的字节数据,或想数据源写入字节数据

​	2.过滤流:依附于其他流上,不能单独使用,且提供了高级功能,使用起来更加方便

​	3.常用的节点流:1)FileInputStream(输入流)	
			2)FileOutputStream(输出流)

​	4.常用的过滤流:1)BufferedInputStream(输入过滤流)	
			2)BufferedOutputStream(输出过滤流)

​	3)ObjectInputStream		4)ObjectOutputStrem

## BufferedReader属于哪种流?作用是什么?提供的经典方法有哪些?

​	1.BuffereReader是属于高级流,只能连接在其他字符流上,
		属于字符流,底层依赖于其他字符流和字节流.
		其提供了字符的缓冲功能,能够一定程度上的提升IO的性能

## 字节流和字符流又哪些区别?

​	1.java中最基本的流时字节流,任何流的底层都是字节流

​	2.字符流是以字符为单位进行读写的流,大多的实现是高级流.
		但其底层一定是基于字节流,字符流在字节流基础上扩展了字符编码解码的功能

​	3.字节流的父类是:InputStream	OutputStream

​	4.字符流的父类是:Reader	Writer

## 什么是对象序列化?什么是反序列化?实例对象序列化需要做哪些工作?

​	1.对象序列化是将对象中的数据编码为字节序列的过程
		//ObjectOutputStream oos = new ObjectOutputStream(fos);

​	2.反序列化是将对象的编码字节重新反向解码为对象的过程

​	3.实例对象序列化要做的工作:

​		1)被序列化的对象需要实现序列化接口,
		此接口是标志接口,没有任何声明的抽象方法,
		java编译器识别这个接口后,自动的为这个类添加序列化和反序列化方法

​		2)在类中添加序列化版本号能保持序列化过程的稳定性

​		3)在硬盘上加transient能避免字段放到硬盘上